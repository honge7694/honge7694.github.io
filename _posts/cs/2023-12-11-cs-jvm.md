---
title: "JVM이란 무엇일까?"
date: 2023-12-11 18:00:00 +09:00
categories: [IT, CS]
tags: [til, jvm, cs, thread, process]
image: /assets/img/posts/cs.png
---

## JVM이란?

Java Virtual Machine의 줄임말로 직역하면 자바를 실행하기 위한 가상 기계(컴퓨터)라고 할 수 있다. Java는 OS에 종속적이지 않다는 특징을 갖고 있는데, OS 위에서 Java를 실행시킬 무언가가 필요하다. 즉 JVM은  **OS에 종속받지 않고 CPU가 Java를 인식하고 실행**할수 있게 해주는 것이다. JVM에는 JRE(Java Runtime Environment)에 포함되어 있다. 현재 사용하는 컴퓨터의 운영체제 맞는 자바 실행환경(JRE)가 설치되어 있다면 자바 가상 머신이 설치되어 있다는 뜻이다.

![image](https://github.com/honge7694/honge7694.github.io/assets/76715487/0f9a15ee-c0c2-4ba7-9c6a-0392be99b1ca)

Java언어로 작성된 .java 파일을 컴파일하면 하나의 바이트 코드(.class)가 생성되며 생성된 바이트 코드는 각자 OS에 설치되어 있는 자바 가상 머신(JVM)이 운영체제에 맞는 실행파일로 바꿔 모든 플랫폼에서 동작할 수 있도록 할 수 있다.

> **.class 파일이란?**     
> .class 파일은 바이트 코드라고 하는데 사람이 쓰는 자바 코드에서 컴퓨터가 읽는 기계어로의 중간 단계라고 생각하면 된다.
{: .prompt-tip }

#### Java는 플랫폼에 종속적이지 않지만 JVM은 플랫폼에 종속적이다.
Java는 컴파일된 바이트코드로 어떤 JVM에서도 동작시킬 수 있기 때문에 OS에 의존적이지 않는다. 하지만 반대로 자바 가상 머신(JVM)은 OS에 의존적이다. 즉 윈도우와 리눅스의 JVM은 서로 다르다. 자바로 작성된 모든 프로그램은 자바 가상 머신에서만 실행될 수 있으므로, 자바 프로그램을 실행하기 위해서는 반드시 자바 가상 머신이 설치되어 있어야한다.

<br/>

## JVM 구성요소

![image](https://github.com/honge7694/honge7694.github.io/assets/76715487/8351ea8e-7f84-4b4c-a0c7-dac88ba8f9f4)

### 클래스 로더(Class Loader)
JVM 내로 .class(바이트 코드) 파일을 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈이다. 자바에서 소스를 작성하면 .java파일이 생성되고, .java 소스를 컴파일러가 컴파일하면, .class 파일이 생성되는데 클래스 로더는 .class(바이트 코드) 파일을 묶어서 JVM이 운영체제로부터 할당받은 메모리 영역인 Runtime Data Area로 적재한다.    
즉, 클래스 로더는 클래스 파일을 찾아 읽어들이고, 그것을 바이트 코드로 변환하여 JVM의 메모리에 올린다.

### 실행 엔진(Execution Engine)
클래스를 실행시키는 역할이다. 클래스 로더에 의해 JVM 내의 Runtime Data Area에 .class(바이트 코드)를 배치시키고, 이후에 JVM은 Method Area의 바이트 코드를 실행 엔진(Execution Engine)에 제공하여, 정의된 내용대로 바이트 코드를 실행시킨다. **이때, 로드된 .class(바이트코드)를 실행하는 런타임 모듈이 실행 엔진(Execution Engine)** 이다. 실행 엔진은 바이트코드를 명령어 단위로 읽어서 실행합니다.

#### 인터프리터(Interpreter)
인터프리터는 실행 엔진의 한 종류로, Java 컴파일러로 .java파일에서 .class파일로 변환된 바이트 코드를 한 줄씩 해석하고 실행한다. 인터프리터는 바이트 코드를 직접 실행하기 때문에 빠른 실행 속도를 보장하지는 않는다.

#### JIT 컴파일러(Just-In-Time)
JIT 컴파일러는 인터프리터의 성능을 개선하기 위한 기술로, 실행 중에 바이트 코드를 기계어로 변환하여 캐시에 저장한다. 이후 같은 코드가 다시 실행될 때는 캐시된 기계어를 사용하여 실행 속도를 향상시킨다.

#### 가비지 콜렉터(Garbage Collector)
가비지 콜렉터는 더 이상 참조되지 않는 객체를 찾아 메모리에서 제거하는 역할을 한다. 자바에서는 메모리 관리를 자동화하기 위해 가비지 콜렉터를 사용하여 프로그래머가 명시적으로 메모리를 해제할 필요가 없다. 가비지 콜렉터는 JVM의 일부로 실행되며, 프로그램이 실행되는 동안 주기적으로 동작한다.

### 런타임 데이터 영역(Runtime Data Area)

![image](https://github.com/honge7694/honge7694.github.io/assets/76715487/edbd2cd3-e286-4b9c-b43f-71f4fa56e0d6)

프로그램이 실행되는 동안에 사용되는 데이터를 저장하는 메모리 영역이다.

> **프로세스(process)란?**    
> 프로세스는 운영체제에서 실행 중인 프로그램의 인스턴스를 의미한다.     
> 각 프로세스는 독립된 메모리 공간을 가지며, 프로세스 간에는 데이터 공유가 어렵고, 각각의 프로세스는 독립적으로 실행된다.     
> 프로세스는 최소한 하나의 스레드를 가지고 있으며, 프로세스 내에서 실행되는 스레드는 해당 프로세스의 자원에 대한 접근이 가능하다.
{: .prompt-tip }

<br/>

> **스레드(thread)란?**    
> 스레드는 프로세스 내에서 실행되는 흐름의 단위를 의미한다.     
> 각 프로세스는 하나 이상의 스레드를 가질 수 있으며, 각 스레드는 프로세스 내의 메모리를 공유하고, 동시에 여러 작업을 수행할 수 있다.    
>  스레드는 프로세스 내에서 공유된 자원에 대한 접근을 통제하고, 프로세스의 실행을 조정하는 역할을 한다.    
>  또한, 두 개 이상의 스레드를 가지는 프로세스를 멀티스레드 프로세스(multi-threaded process)라고 한다.    
{: .prompt-tip }


#### PC Register
스레드가 생성될 때마다 생성되는 영역으로 스레드마다 하나씩 존재한다. 현재 스레드가 실행되는 부분의 JVM 명령의 주소를 저장하고 있는 영역이다.

#### 스택 영역

**프로그램 실행과정에서 임시로 할당되었다가 메소드를 빠져나가면 바로 소멸되는 특성의 데이터를 저장하기 위한 영역이다.**

+ 메소드 호출과 관련된 값들을 매개변수, 지역변수, 리턴 값 및 연산 시 일어나는 값 등을 임시로 저장한다.
+ 메서드가 호출될 때 스택 프레임이 생성되고, 메서드가 반환될 때 스택 프레임이 제거된다.

#### Heap 영역

![image](https://github.com/honge7694/honge7694.github.io/assets/76715487/90ea6e65-a63e-4185-817d-bb3c404da015)

객체를 저장하는 가상 메모리 공간이다. new 연산자로 생성되는 객체와 배열을 저장한다. 주기적으로 GC가 제거하는 영역이다.

+ Young Generation(영속성영역)     
새로 생성된 객체가 할당되는 영역이다. 대부분의 객체는 이 영역에서 생성되며, 객체가 오랫동안 살아남으면 Old Generation으로 이동한다. Eden 영역과 두 개의 Survivor 영역으로 나뉜다.
	+ Eden : 새로 생성된 객체들이 할당되는 초기 영역
	+ Survivor : Eden 영역에서 살아남은 객체들이 이동하는 영역이다. 가비지 컬렉션 과정에서 일정 시간 동안 살아남은 객체들은 이 영역으로 이동한다.

+ Old Generation(노인 영역 또는 Tenured 영역)
오랫동안 살아남은 객체가 할당되는 영역이다. Young Generation에서 일정 횟수의 가비지 컬렉션을 거친 후에 살아남은 객체들이 이동한다.

+ Permanent(퍼먼트 영역)
생성된 객체들의 정보의 주소값이 저장된 공간이다. 클래스 로더에 의해 load되는 Class, Method 등에 대한 Meta 정보가 저장되는 영역이고 JVM에 의해 사용된다.
Reflection을 사용하여 동적으로 클래스가 로딩되는 경우에 사용된다.

> **Garbage Collector**     
> Young 영역에서 일어나는 가비지 콜렉터를 Minor Garbage Collector라고 하며, 생명주기가 짧은 젊은 객체를 대상으로 일어난다.    
> Old 영역에서 일어나는 가비지 콜렉터는 Major Garbage Collector라고 하며, 생명주기가 긴 "오래된 객체"를  대상으로 일어난다. Minor Garbage Collector에 비해 속도가 느리다. 
{: .prompt-tip }

<br/>

***

<br/>

#### **핵심 키워드 : 바이트 코드, class 파일, 기계어, 자연어**

<br/>

> **나의 답변**    
JVM은 OS에 상관없이 어디서든 JAVA 애플리케이션을 실행할 수 있게 합니다. JVM은 자바 가상 머신(Java Virtual Machine)의 약자로, 자바 바이트코드를 실행하는 가상 환경을 제공하는 프로그램입니다. 자바로 작성된 소스 코드는 컴파일되어 바이트코드로 변환되고, JVM은 이 바이트코드를 해석하며 실행환경을 제공합니다.
{: .prompt-warning }

<br/>

## 참고

+ [doozi0316 티스토리](https://doozi0316.tistory.com/entry/1%EC%A3%BC%EC%B0%A8-JVM%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B4%EB%A9%B0-%EC%9E%90%EB%B0%94-%EC%BD%94%EB%93%9C%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%8B%A4%ED%96%89%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B8%EA%B0%80)
+ [코딩팩토리](https://coding-factory.tistory.com/828)



