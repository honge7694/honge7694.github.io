---
title: 항해99 일지(33) - WIL
date: 2024-01-14 18:00:00 +09:00
categories: [IT, WIL]
tags: [항해99, wil]
image: /assets/img/posts/logbook99.png
---


## 항해 프로젝트 끝

길고 긴 항해 프로젝트가 끝났다. 우리팀은 저번에 진행했던 대로 대용량 트래픽에 대응한 티켓예매 프로젝트였다. 나는 redis를 이용하여 대기열을 만들고, 대기열에서 사람들을 순차적으로 내보내어, 예매를 하는 부분을 맡아서 했다.

<br/>

또, AWS의 다양한 서비스들을 다뤄봤다. codedeploy, s3, alb, autoscaling, iam 등등 처음 써보는 서비스들 투성이였다. 그리고 또 postgresql을 사용하면서 새로운 db도 만져보며, ORM의 편리함을 다시 한번 깨닫게 되었다. 그리고 모니터링을 해보며 어디가 문제인지 코드를 보지않고 찾는 것도 신기했다.

<br/>

지금와서 말하지만 프로젝트는 실패했다. 생각했던 퍼포먼스를 보여줄 수 없었다. 개발은 일찍 끝났지만, 성능을 개선하기 위해 할 수 있는 것들이 서버를 만져보는 것, 그리고 코드를 개선하는 것인데, 서버를 만지는 것부터 꼬였다. nginx를 튜닝하면서 개선했지만, 너무 request 숫자를 높이는데에만 신경써 nginx의 튜닝이 어떤 역할을 하는지 놓치고 말았다. 그리고 또 코드의 개선보다 서버의 개선만 너무 신경썼다. 시나리오도 지나고 보니 왜 이렇게 짠건가 싶은 시나리오들이였다. 조금 아쉽지만 이 실패한 것을 토대로 다시 개선한다면 좋지않을까싶다.


## 그래서 어떤 것을 개선해야하지?

### 1. DB .save()  .saveall()
프로젝트에서 bulk insert라고 작성하였지만, saveall()을 사용했었다. 이것을 직접 구현해보는게 어떠냐고 멘토님께 조언을 받았다. 한번 이것을 직접 구현해보며, 속도를 비교해보는 것도 정말 좋을 것 같다.

### 2. Blue, Green 배포
CI/CD Blue, Green 배포 하는 것을 하나의 EC2안에 2개의 포트를 사용하여 번갈아가며 배포를 하였다. 하지만 이런 방식보다는, EC2 2개를 사용하여 각각의 인스턴스에 Blue, Green을 넣어줘야 하는 것이 맞다고 해주셨다. 이 부분은 과금의 양이 너무 많기 때문에, 개선한 후 마지막에 한번 개선 할 예정이다.

### 3. redis와 kafka
redis는 인메모리방식으로 EC2 인스턴스가 종료가 된다면, 대기열이 모두 사라진다. 티켓 예매 프로젝트에서 제일 중요한 것은 무엇인가? 바로 순서를 보장해주는 것이다. 이 문제를 해결하기 위해 디스크에 데이터를 저장하는 kafka를 사용할 수 있다. 또한 redis에서 **AOF(Append-Only-File)** 방식을 사용하여 추가적으로 데이터를 디스크에 저장할 수 있다.    
또는 Amazon ElastiCache를 사용하여 Redis를 분산 저장하여 처리할 수 있다는데 한번 여러가지 방법으로 개선해 나갈 예정이다.


### 4. 티켓 정보 조회 캐싱
예매를 할 때마다 티켓의 정보를 가져오는데, 이를 캐싱하면 어떨까 라는 생각을 하였다. 이 방법도 적용해본다면 좀 더 빠른 성능과 리소스 효율성을 가져갈 수 있을거라는 생각이 들었다.
캐시의 유효기간을 설정하고, **캐시는 메모리에 사용**되므로 메모리 부족현상을 생각하며 개선해야한다.


### 5. 대기열에 속한 인원 보이기
대기열에 들어간 인원들이 몇번째 인지 실시간으로 보여주는 것을 하려한다. 이것을 하려면 어떤 방식을 사용해야할지, 아직 고민이 있다. 현재 로직으로는 하나의 유저가 여러번 티켓을 예매하여 대기열에 쌓이는 형식인데, 유저가 자신은 몇번째 대기열인지 알게하고싶다. 일단 이것을 개선하기위한 방법도 찾아봐야 한다.


## 목표는??
처음 잡았던 목표인 대규모 트래픽 상황에서 시스템의 고가용성 확보하고, 동시성 제어를 통해 데이터베이스의 일관성 유지하며, 들어온 요청을 선착순으로 처리하는 예매 서비스를 그대로 하되, 성능과 코드를 왜 이렇게 짯는지에 대한 타당성을 꼭 챙겨가고싶다.

